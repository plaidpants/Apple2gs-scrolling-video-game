program Create;uses	QDIntf,	GSIntf,		MiscTools,	ConsoleIO,	Prodos16,	FontMgr,	ListMgr,	PrintMgr,	CreateUnit;{$Cseg codetwo}procedure SetUpCrossCursor;	var		addr:longint;	begin		with CrossCursor do			begin				addr := Ord4(@data);				StuffHex(addr,'00000F0000000000');				StuffHex(addr+8,'00000F0000000000');				StuffHex(addr+16,'00000F0000000000');				StuffHex(addr+24,'00000F0000000000');				StuffHex(addr+32,'00000F0000000000');				StuffHex(addr+40,'FFFFFFFFFFF00000');				StuffHex(addr+48,'00000F0000000000');				StuffHex(addr+56,'00000F0000000000');				StuffHex(addr+64,'00000F0000000000');				StuffHex(addr+72,'00000F0000000000');				StuffHex(addr+80,'00000F0000000000');				StuffHex(addr+88,'0000000000000000');				StuffHex(addr+96,'0000000000000000');				StuffHex(addr+104,'0000000000000000');				StuffHex(addr+112,'0000000000000000');				StuffHex(addr+112,'0000000000000000');				StuffHex(addr+128,'0000000000000000');				StuffHex(addr+136,'0000000000000000');				StuffHex(addr+144,'0000000000000000');				StuffHex(addr+152,'0000000000000000');				StuffHex(addr+160,'0000000000000000');				StuffHex(addr+168,'0000000000000000');				hotSpot.h:=5;				hotSpot.v:=5;				CursorHeight:=11;				CursorWidth:=4;			end;	end;	Procedure SetUpColors;var	i,j,k:integer;	begin	for i:=0 to 15 do		GetColorTable(0,Colors[i]);		for k:=0 to 3 do		for i:=0 to 7 do			for j:=0 to 1 do				begin					SelectPatterns[k,(8*i+j+0+k*2) mod 16]:=$00FF;					SelectPatterns[k,(8*i+j+2+k*2) mod 16]:=$0FF0;					SelectPatterns[k,(8*i+j+4+k*2) mod 16]:=$FF00;					SelectPatterns[k,(8*i+j+6+k*2) mod 16]:=$F00F;				end;end;procedure  DoLoadShape;		begin	with TypeList do		begin			NumEntries:=1;			FileType1:=$00;		end;	SFGetFile(50,20,'Load Shape File:',nil,@TypeList,MyReply);	if myReply.good then		begin			P16Blk.pathname2:=@myReply.fullpathname;			P16Blk.ioBuffer:=nil;			P16Open(P16Blk);			P16Blk.databuffer:=ShapeHandle^;			P16Blk.requestcount:=GetHandleSize(ShapeHandle);			P16Read(P16Blk);			P16Close(P16Blk);				UpdateShapeOffscreen;			SetPort(TerrainWindPtr);			InvalRect(TerrainWindPtr^.PortRect);			SetPort(ShapeWindPtr);			InvalRect(ShapeWindPtr^.PortRect);		end;end;procedure  DoLoadTerrain;begin	with TypeList do		begin			NumEntries:=1;			FileType1:=$00;		end;	SFGetFile(50,20,'Load Terrain File:',nil,@TypeList,MyReply);	if myReply.good then		begin			P16Blk.pathname2:=@myReply.fullpathname;			P16Blk.ioBuffer:=nil;			P16Open(P16Blk);			P16Blk.databuffer:=@Terrain;			P16Blk.requestcount:=256*256;			P16Read(P16Blk);			P16Close(P16Blk);			SetPort(TerrainWindPtr);			InvalRect(TerrainWindPtr^.PortRect);		end;end;procedure  DoLoadColors;begin	with TypeList do		begin			NumEntries:=1;			FileType1:=$00;		end;	SFGetFile(50,20,'Load Colors File:',nil,@TypeList,MyReply);	if myReply.good then		begin			P16Blk.pathname2:=@myReply.fullpathname;			P16Blk.ioBuffer:=nil;			P16Open(P16Blk);			P16Blk.databuffer:=@Colors;			P16Blk.requestcount:=sizeof(Colors);			P16Read(P16Blk);			P16Close(P16Blk);		end;end;Procedure DoSaveTerrain;		Begin	SFPutFile(50,20,'Save Terrain as:','TERRAIN',15,myReply);	if myReply.good then		begin			P16Blk.deletepathname:=@myReply.fullpathname;   		P16Destroy(P16Blk);   		P16Blk.pathname1:=@myReply.fullpathname;   		P16Blk.access:=$C3;   		P16Blk.fileType:=$00;   		P16Blk.auxType:=0;   		P16Blk.storageType:=1;   		P16Blk.CreateDate:=0;   		P16Blk.CreateTime:=0;   		P16Create(P16Blk);   		P16Blk.pathname2:=@myReply.fullpathname;   		P16Blk.ioBuffer:=nil;   		P16Open(P16Blk);   		P16Blk.databuffer:=@Terrain;   		P16Blk.requestcount:=256*256;   		P16Write(P16Blk);   		P16Close(P16Blk);		end;end;Procedure DoSaveShape;		  Begin   SFPutFile(50,20,'Save Shape as:','Shapee',15,myReply);   if myReply.good then   	begin			P16Blk.deletepathname:=@myReply.fullpathname;   		P16Destroy(P16Blk);   		P16Blk.pathname1:=@myReply.fullpathname;   		P16Blk.access:=$C3;   		P16Blk.fileType:=$00;   		P16Blk.auxType:=0;   		P16Blk.storageType:=1;   		P16Blk.CreateDate:=0;   		P16Blk.CreateTime:=0;   		P16Create(P16Blk);   		P16Blk.pathname2:=@myReply.fullpathname;   		P16Blk.ioBuffer:=nil;   		P16Open(P16Blk);   		P16Blk.databuffer:=ShapeHandle^;   		P16Blk.requestcount:=256*32*16;   		P16Write(P16Blk);   		P16Close(P16Blk);		end;  end;  procedure DoAbout;var	aboutDlog:DialogPtr;	r:Rect;  begin	setRect(r,20,30,300,170);	aboutDlog := NewModalDialog(r,true,0);	SetPort(aboutDlog);	SetRect(r,100,120,175,135);	SetBackColor(15);	SetForeColor(0);	NewDItem(aboutDlog,1,r,10,@' Okay ',0,0,nil);	SetDefButton(1,aboutDlog);	moveto(10,20);	DrawString('Terrain & Shape Editor v1.0');	SetForeColor(0);	moveto(10,50);	DrawString('  Written by:');	moveto(10,70);	DrawString('  Jim Surine');	moveto(10,80);	DrawString('  1995 W Kenwood Dr.');	moveto(10,90);	DrawString('  St Paul, MN 55117');	moveto(10,100);	DrawString('  (Using TML Pascal v1.5)');	SetForeColor(5);	moveto(10,110);	DrawString('  Dedicated to Amye.');		SetForeColor(0);  repeat	until ModalDialog(nil) = 1;	CloseDialog(aboutDlog);end;	procedure Anal;	var		i,j,center,down,right:integer;			begin		for i:=0 to 255 do			for j:=0 to 255 do				begin						LeftRight[i,j]:=0;					updown[i,j]:=0;				end;		if tool<>2 then		for i:=0 to 255 do			for j:=0 to 255 do				begin					center:=terrain[j,i];					right:=terrain[j,(i+1) mod 256];					down:=terrain[(j+1) mod 256,i];					LeftRight[center,right]:=LeftRight[center,right]+1;					if LeftRight[center,right]>63 then						LeftRight[center,right]:=63;					updown[center,down]:=updown[center,down]+1;					if updown[center,down]>63 then						updown[center,down]:=63;				end	else		for i:=SelectRect.left to SelectRect.Right do			for j:=SelectRect.top to SelectRect.bottom do				begin					center:=terrain[j,i];					right:=terrain[j,(i+1) mod 256];					down:=terrain[(j+1) mod 256,i];					LeftRight[center,right]:=LeftRight[center,right]+1;					if LeftRight[center,right]>63 then						LeftRight[center,right]:=63;					updown[center,down]:=updown[center,down]+1;					if updown[center,down]>63 then						updown[center,down]:=63;				end;						for i:=0 to 255 do			begin				LeftRight[i,0]:=1;				LeftRight[0,i]:=1;				updown[i,0]:=1;				updown[0,i]:=1;			end;	end;	procedure Create;	var		i,j,k:integer;		up,right,down,left,center:integer;		Shapes:Array[1..255] of longint;		TheRandom,MaxRandom:longint;		Width,XStart,Height,YStart:integer;			begin		for i:=SelectRect.left to SelectRect.Right do			for j:=SelectRect.top to SelectRect.bottom do				if terrain[j,i]=0 then					begin						up:=terrain[(j+255) mod 256,i];						down:=terrain[(j+1) mod 256,i];						left:=terrain[j,(i+255) mod 256];						right:=terrain[j,(i+1) mod 256];						Center:=0;						MaxRandom:=0;												for k:=1 to 255 do							Shapes[k]:=ord4(updown[up,k])*ord4(updown[k,down])*ord4(LeftRight[left,k])*ord4(LeftRight[k,Right]);						for k:=1 to 255 do							begin								TheRandom:=Shapes[k]*abs(random mod 16);								if TheRandom>MaxRandom then									begin										Center:=k;										MaxRandom:=TheRandom;									end;							end;													terrain[j,i]:=Center;						if keypressed then							exit;					end;		setPort(TerrainWindPtr);		invalRect(TerrainWindPtr^.portRect);	end;function CreateSquare(i,j:integer):integer;	var		k,up,right,down,left,center:integer;		found:boolean;			begin		up:=terrain[(j+255) mod 256,i];		down:=terrain[(j+1) mod 256,i];		left:=terrain[j,(i+255) mod 256];		right:=terrain[j,(i+1) mod 256];		Center:=terrain[j,i];		found:=false;				for k:= center+1 to 255 do			if (updown[up,k]<>0) and (updown[k,down]<>0) and (LeftRight[left,k]<>0) and (LeftRight[k,Right]<>0) then				begin					Found:=true;					leave;				end;						if not found then			k:=0;				terrain[j,i]:=k;		CreateSquare:=k;	end;procedure DoPrint;	var    myPrPort:TPPrport; 		begin		if frontwindow=terrainWindPtr then			begin				myPrPort := PrOpenDoc(PrintHdl,nil);				PrOpenPage(myPrPort,nil);				UpdateTerrainWindow;				PrClosePage(myPrPort);				PrCloseDoc(myPrPort);				PrPicFile(PrintHdl,nil,nil);			end;		if frontwindow=ShapeWindPtr then			begin				myPrPort := PrOpenDoc(PrintHdl,nil);				PrOpenPage(myPrPort,nil);				UpdateShapeWindow;				PrClosePage(myPrPort);				PrCloseDoc(myPrPort);				PrPicFile(PrintHdl,nil,nil);			end;  end;  procedure HandleEditorWindowInContent(Event:EventRecord);var	ShapeRect,	DestRect,	TempRect,	TempRect2:Rect;	begin	SetRect(DestRect,0,0,32,32);	OffsetRect(DestRect,0,32*ShapeWindowShapeNumber);	SetPort(ShapePort);	ClipRect(DestRect);	SetRect(DestRect,0,0,Scale,Scale);	OffsetRect(DestRect,ShapeWindowShapeNumber div 16 *Scale-HiWord(GetContentOrigin(ShapeWindPtr)),ShapeWindowShapeNumber mod 16 *Scale-LoWord(GetContentOrigin(ShapeWindPtr)));	SetPort(ShapeWindPtr);	ClipRect(DestRect);	SetRect(ShapeRect,-4*(brushSize-1) div 2,-4*(brushSize-1) div 2,4*(brushSize+1) div 2,4*(brushSize+1) div 2);	SetRect(DestRect,-brushSize div 2,-brushSize div 2,(brushSize+1) div 2,(brushSize+1) div 2);	SetRect(TempRect2,-brushSize*Scale div 64,-brushSize*Scale div 64,(brushSize+1)*Scale div 64,(brushSize+1)*Scale div 64);	SetPort(EditorWindPtr);	GlobaltoLocal(Event.Where);	while StillDown(0) do		begin			if ptinRect(Event.Where,EditorWindPtr^.PortRect) then				begin					TempRect:=ShapeRect;					OffsetRect(TempRect,Event.Where.h div 4*4,Event.Where.v div 4*4);					SetSolidPenPat(PaletteColorNumber);					PaintRect(TempRect);					Case GridOption of					1:PPtoPort(GridPort^.PortInfo,TempRect,TempRect.left,TempRect.top,NotSrcBic);					2:PPtoPort(GridPort^.PortInfo,TempRect,TempRect.left,TempRect.top,NotSrcOR);					3:PPtoPort(GridPort^.PortInfo,TempRect,TempRect.left,TempRect.top,NotSrcXOR);					end;												SetPort(ShapeWindPtr);					SetSolidPenPat(PaletteColorNumber);					SetPenMode(SrcCopy);					TempRect:=TempRect2;					OffsetRect(TempRect,Event.Where.h div (128 div scale)+ShapeWindowShapeNumber div 16 * scale-HiWord(GetContentOrigin(ShapeWindPtr))						,Event.Where.v div (128 div scale) +ShapeWindowShapeNumber mod 16 * scale-LoWord(GetContentOrigin(ShapeWindPtr)));					PaintRect(TempRect);										SetPort(ShapePort);					SetSolidPenPat(PaletteColorNumber);					TempRect:=destRect;					OffsetRect(TempRect,Event.Where.h div 4,Event.Where.v div 4+ShapeWindowShapeNumber*32);					PaintRect(TempRect);				end;			SetPort(EditorWindPtr);			GetMouse(Event.Where);		end;	SetRect(TempRect,0,0,32,32);	SetRect(TempRect2,0,0,scale,scale);	OffsetRect(TempRect,0,32*ShapeWindowShapeNumber);	OffsetRect(TempRect2,ShapeWindowShapeNumber div 16 *scale,ShapeWindowShapeNumber mod 16*scale);	CopyPixels(ShapePort^.PortInfo,ShapeOffscreenPort^.PortInfo,TempRect,TempRect2,SrcCopy,ShapeOffscreenPort^.VisRgn);	OffsetRect(TempRect2,-HiWord(GetContentOrigin(ShapeWindPtr)),-LoWord(GetContentOrigin(ShapeWindPtr)));	CopyPixels(ShapePort^.PortInfo,ShapeWindPtr^.PortInfo,TempRect,TempRect2,SrcCopy,ShapeWindPtr^.VisRgn);						SetPort(ShapePort);	SetRect(TempRect,0,0,32,256*32);	ClipRect(TempRect);	SetPort(ShapeWindPtr);	SetSolidPenPat(15);	SetPenMode(SrcXor);	FrameRect(TempRect2);	SetRect(TempRect,0,0,16*32,16*32);	ClipRect(TempRect);		SetPort(TerrainWindPtr);	invalRect(terrainWindPtr^.PortRect);end;procedure drawselect;var	therect:rect;	begin	if SelectRect.left>SelectRect.right then		begin			theRect.Left:=SelectRect.right*Scale;			theRect.Right:=(SelectRect.left+1)*Scale;		end	else		begin			theRect.Left:=SelectRect.Left*Scale;			theRect.Right:=(SelectRect.Right+1)*Scale;		end;	if SelectRect.top>SelectRect.bottom then		begin			theRect.top:=SelectRect.bottom*Scale;			theRect.bottom:=(SelectRect.top+1)*Scale;		end	else		begin			theRect.top:=SelectRect.top*Scale;			theRect.bottom:=(SelectRect.bottom+1)*Scale;		end;	StartDrawing(TerrainWindPtr);	setPenPat(selectPatterns[SelectPatternNumber]);	setPenMode(SrcXor);	frameRect(theRect);	SelectPatternNumber:=(SelectPatternNumber+1) mod 4;	frameRect(theRect);	setorigin(0,0);	SetPenMode(srcCopy);end;procedure HandleTerrainWindowInContent(Event:EventRecord);var	TempRect,	ShapeRect:rect;	i,j,ShapeNumber:integer;	Origin:longint;	x,y:integer;	temp:integer;	begin	SetRect(ShapeRect,0,0,scale,scale);	SetPort(TerrainWindPtr);	GlobaltoLocal(Event.Where);	case tool of	0:	while StillDown(0) do		begin			if ptinRect(Event.Where,TerrainWindPtr^.PortRect) then				begin					j:=Event.Where.v+LoWord(GetContentOrigin(TerrainWindPtr));					i:=Event.Where.h+HiWord(GetContentOrigin(TerrainWindPtr));					ShapeNumber:=ShapeWindowShapeNumber;					terrain[j div Scale,i div Scale]:=ShapeWindowShapeNumber;					TempRect:=ShapeRect;					OffsetRect(TempRect,ShapeNumber div 16 *scale,ShapeNumber mod 16 *scale);					PPtoPort(ShapeOffscreenPort^.PortInfo,TempRect,(i div Scale)*Scale-HiWord(GetContentOrigin(TerrainWindPtr))						,(j div Scale)*Scale-LoWord(GetContentOrigin(TerrainWindPtr)),SrcCopy);				end;			GetMouse(Event.Where);		end;	1:		if ptinRect(Event.Where,TerrainWindPtr^.PortRect) then			begin				j:=Event.Where.v+LoWord(GetContentOrigin(TerrainWindPtr));				i:=Event.Where.h+HiWord(GetContentOrigin(TerrainWindPtr));				ShapeNumber:=CreateSquare(i div Scale,j div Scale);				TempRect:=ShapeRect;				OffsetRect(TempRect,ShapeNumber div 16 *scale,ShapeNumber mod 16 *scale);				PPtoPort(ShapeOffscreenPort^.PortInfo,TempRect,(i div Scale)*Scale-HiWord(GetContentOrigin(TerrainWindPtr))					,(j div Scale)*Scale-LoWord(GetContentOrigin(TerrainWindPtr)),SrcCopy);			end;		2:			begin				SelectRect.left:=(Event.Where.h+HiWord(GetContentOrigin(TerrainWindPtr))) div Scale;				SelectRect.Top:=(Event.Where.v+LoWord(GetContentOrigin(TerrainWindPtr))) div Scale;				SelectRect.right:=SelectRect.left;				SelectRect.Bottom:=SelectRect.Top;				while StillDown(0) do					begin						drawselect;						if ptinRect(Event.Where,TerrainWindPtr^.PortRect) then							begin								SelectRect.right:=(Event.Where.h+HiWord(GetContentOrigin(TerrainWindPtr))) div Scale;								SelectRect.Bottom:=(Event.Where.v+LoWord(GetContentOrigin(TerrainWindPtr))) div Scale;							end						else							begin								Origin:=GetContentOrigin(TerrainWindPtr);								x:=HiWord(Origin);								y:=LoWord(Origin);								if Event.Where.h<TerrainWindPtr^.PortRect.left then									begin										x:=x-4*Scale;										if x<0 then											x:=0;									end								else									if Event.Where.h>TerrainWindPtr^.PortRect.Right then										begin											x:=x+4*Scale;											if x+(TerrainWindPtr^.PortRect.Right-TerrainWindPtr^.PortRect.left)>Scale*256 then												x:=Scale*256-(TerrainWindPtr^.PortRect.Right-TerrainWindPtr^.PortRect.left);										end;								if Event.Where.v<TerrainWindPtr^.PortRect.top then									begin										y:=y-4*Scale;										if y<0 then											y:=0;									end								else									if Event.Where.v>TerrainWindPtr^.PortRect.Bottom then										begin											y:=y+4*Scale;											if y+(TerrainWindPtr^.PortRect.Bottom-TerrainWindPtr^.PortRect.Top)>Scale*256 then												y:=Scale*256-(TerrainWindPtr^.PortRect.Bottom-TerrainWindPtr^.PortRect.top);										end;													SetContentOrigin(x,y,TerrainWindPtr);					end;				GetMouse(Event.Where);			end;			if SelectRect.right<SelectRect.left then				begin					temp:=SelectRect.right;					SelectRect.right:=SelectRect.left;					SelectRect.left:=temp;				end;			if SelectRect.bottom<SelectRect.top then				begin					temp:=SelectRect.bottom;					SelectRect.bottom:=SelectRect.top;					SelectRect.top:=temp;				end;		end;	end;end;Procedure HandleShapeWindowInContent(Event:EventRecord);var	ShapeRect,	DestRect:rect;	Origin:longint;	x,y:integer;	begin	SetPort(ShapeWindPtr);	GlobalToLocal(Event.Where);	SetSolidPenPat(15);	SetPenMode(SrcXor);		while StillDown(0) do		begin			if ptinRect(Event.Where,ShapeWindPtr^.PortRect) then				begin					SetRect(ShapeRect,0,0,Scale,Scale);					OffsetRect(ShapeRect,ShapeWindowShapeNumber div 16*Scale-HiWord(GetContentOrigin(ShapeWindPtr)),ShapeWindowShapeNumber mod 16*Scale-LoWord(GetContentOrigin(ShapeWindPtr)));					FrameRect(ShapeRect);								ShapeWindowShapeNumber:=(Event.Where.h+HiWord(GetContentOrigin(ShapeWindPtr))) div Scale  *16+ (Event.Where.v +LoWord(GetContentOrigin(ShapeWindPtr))) div Scale ;					SetRect(ShapeRect,0,0,Scale,Scale);					OffsetRect(ShapeRect,ShapeWindowShapeNumber div 16 * Scale-HiWord(GetContentOrigin(ShapeWindPtr)),ShapeWindowShapeNumber mod 16 *Scale-LoWord(GetContentOrigin(ShapeWindPtr)));					FrameRect(ShapeRect);				end			else				begin					Origin:=GetContentOrigin(ShapeWindPtr);					x:=HiWord(Origin);					y:=LoWord(Origin);					if Event.Where.h<ShapeWindPtr^.PortRect.left then						begin							x:=x-Scale;							if x<0 then								x:=0;						end					else						if Event.Where.h>ShapeWindPtr^.PortRect.Right then							begin								x:=x+Scale;								if x+(ShapeWindPtr^.PortRect.Right-ShapeWindPtr^.PortRect.left)>Scale*16 then									x:=Scale*16-(ShapeWindPtr^.PortRect.Right-ShapeWindPtr^.PortRect.left);							end;					if Event.Where.v<ShapeWindPtr^.PortRect.top then						begin							y:=y-Scale;							if y<0 then								y:=0;						end					else						if Event.Where.v>ShapeWindPtr^.PortRect.Bottom then							begin								y:=y+Scale;								if y+(ShapeWindPtr^.PortRect.Bottom-ShapeWindPtr^.PortRect.Top)>Scale*16 then									y:=Scale*16-(ShapeWindPtr^.PortRect.Bottom-ShapeWindPtr^.PortRect.top);							end;												SetContentOrigin(x,y,ShapeWindPtr);				end;			GetMouse(Event.Where);		end;	SetPort(EditorWindPtr);	invalRect(EditorWindPtr^.portRect);end;procedure HandlewInContent(Event:EventRecord);begin	if windowptr(Event.TaskData)=TerrainWindPtr then		HandleTerrainWindowInContent(Event);	if windowptr(Event.TaskData)=ShapeWindPtr then		HandleShapeWindowInContent(Event);	if windowptr(Event.TaskData)=EditorWindPtr then		HandleEditorWindowInContent(Event);end;procedure HandleTerrainWindowInInfo(Event:EventRecord);var	infoReft:rect;	begin	SetPort(TerrainWindPtr);	GlobalToLocal(Event.Where);	Tool:=Event.Where.h div 16;	StartInfoDrawing(infoReft,TerrainWindPtr);	UpdateTerrainInfo(infoReft,0,TerrainWindPtr);	EndInfoDrawing;end;procedure HandleEditorWindowInInfo(Event:EventRecord);var	ShapeRect,	DestRect:Rect;	begin	SetPort(EditorWindPtr);	GlobalToLocal(Event.Where);	if Event.Where.v<-16 then		PaletteColorNumber:=Event.Where.h div 8	else		if Event.Where.h>16*4 then			begin				GridOption:=Event.Where.h div 16-4;				invalRect(EditorWindPtr^.PortRect);			end		else			brushSize:=Event.Where.h div 16*2+1;		StartInfoDrawing(ShapeRect,EditorWindPtr);	ClipRect(ShapeRect);	UpdateEditorInfo(ShapeRect,0,EditorWindPtr);	EndInfoDrawing;	if (bitAnd(Event.Modifiers,AppleKey)<>0) and (Event.Where.v<-7) then		begin			SetPort(ShapePort);			SetSolidPenPat(PaletteColorNumber);			SetRect(ShapeRect,0,0,32,32);			OffsetRect(ShapeRect,0,ShapeWindowShapeNumber*32);			PaintRect(ShapeRect);								SetRect(DestRect,0,0,scale,scale);			OffsetRect(DestRect,ShapeWindowShapeNumber div 16 *scale,ShapeWindowShapeNumber mod 16*scale);			CopyPixels(ShapePort^.PortInfo,ShapeOffscreenPort^.PortInfo,ShapeRect,DestRect,SrcCopy,ShapeOffscreenPort^.VisRgn);			OffsetRect(DestRect,-HiWord(GetContentOrigin(ShapeWindPtr)),-LoWord(GetContentOrigin(ShapeWindPtr)));			CopyPixels(ShapePort^.PortInfo,ShapeWindPtr^.PortInfo,ShapeRect,DestRect,SrcCopy,ShapeWindPtr^.VisRgn);			SetPort(ShapeWindPtr);			SetSolidPenPat(15);			SetPenMode(SrcXor);			FrameRect(DestRect);						SetPort(EditorWindPtr);			InvalRect(EditorWindPtr^.PortRect);			SetPort(TerrainWindPtr);			InvalRect(TerrainWindPtr^.PortRect);		end;end;procedure HandlewInInfo(Event:EventRecord);begin	if windowptr(Event.TaskData)=TerrainWindPtr then		HandleTerrainWindowInInfo(Event);	if windowptr(Event.TaskData)=EditorWindPtr then		HandleEditorWindowInInfo(Event);end; procedure ChangeScale; 	begin		CloseWindow(TerrainWindPtr);		CloseWindow(ShapeWindPtr);		UpdateShapeOffscreen;		SetUpTerrainWindow;		SetUpShapeWindow;	end;Procedure DoShapePaste;	var		ShapeRect,		TempRect2:Rect;		i,j:integer;		begin	SetRect(ShapeRect,0,0,32,32);	OffsetRect(ShapeRect,0,32*CopyShapeNumber);	SetPort(ShapePort);	PPtoPort(ShapePort^.PortInfo,ShapeRect,0,32*ShapeWindowShapeNumber,SrcCopy);	SetRect(TempRect2,0,0,scale,scale);	OffsetRect(TempRect2,ShapeWindowShapeNumber div 16 *scale,ShapeWindowShapeNumber mod 16*scale);	CopyPixels(ShapePort^.PortInfo,ShapeOffscreenPort^.PortInfo,ShapeRect,TempRect2,SrcCopy,ShapeOffscreenPort^.VisRgn);	OffsetRect(TempRect2,-HiWord(GetContentOrigin(ShapeWindPtr)),-LoWord(GetContentOrigin(ShapeWindPtr)));	CopyPixels(ShapePort^.PortInfo,ShapeWindPtr^.PortInfo,ShapeRect,TempRect2,SrcCopy,ShapeWindPtr^.VisRgn);	SetSolidPenPat(15);	SetPenMode(srcXor);	FrameRect(TempRect2);	SetPenMode(SrcCopy);		SetPort(EditorWindPtr);	InvalRect(EditorWindPtr^.PortRect);	SetPort(TerrainWindPtr);	InvalRect(TerrainWindPtr^.PortRect);end;Procedure DoAnalyze;beginend;Procedure DoShapeClear;	var		ShapeRect,		TempRect2:Rect;		i,j:integer;		begin	SetRect(ShapeRect,0,0,32,32);	OffsetRect(ShapeRect,0,32*ShapeWIndowShapeNumber);	SetPort(ShapePort);	EraseRect(ShapeRect);	SetRect(TempRect2,0,0,scale,scale);	OffsetRect(TempRect2,ShapeWindowShapeNumber div 16 *scale,ShapeWindowShapeNumber mod 16*scale);	EraseRect(TempRect2);	SetSolidPenPat(15);	SetPenMode(srcXor);	FrameRect(TempRect2);	SetPenMode(SrcCopy);		SetPort(EditorWindPtr);	InvalRect(EditorWindPtr^.PortRect);	SetPort(TerrainWindPtr);	InvalRect(TerrainWindPtr^.PortRect);end;procedure DoTerrainPaste;var	i,j:integer;	begin	for i:=CopyRect.Left to CopyRect.Right do			for j:=CopyRect.Top to CopyRect.Bottom do				Terrain[j+SelectRect.top-CopyRect.Top,i+SelectRect.Left-CopyRect.Left]:=Terrain[j,i];	SetPort(TerrainWindPtr);	InvalRect(TerrainWindPtr^.PortRect);end;procedure DoTerrainClear;var	i,j:integer;	begin	for i:=SelectRect.Left to SelectRect.Right do			for j:=SelectRect.Top to SelectRect.Bottom do				Terrain[j,i]:=ShapeWIndowShapeNumber;	SetPort(TerrainWindPtr);	InvalRect(TerrainWindPtr^.PortRect);end;procedure HandleWInMenuBar(Event:EventRecord);		var		dummy:boolean;		begin		case LoWord(Event.TaskData) of			Aboutitem:				DoAbout;			SaveItem:				begin					if frontWindow=TerrainWindPtr then						DoSaveTerrain;					if frontWindow=ShapeWindPtr then						DoSaveShape;				end;			copyItem,cutItem:				begin					if frontWindow=TerrainWindPtr then						CopyRect:=SelectRect;					if frontWindow=ShapeWindPtr then						CopyShapeNumber:=ShapeWindowShapeNumber;				end;			ClearItem:				begin					if frontWindow=TerrainWindPtr then						DoTerrainClear;					if frontWindow=ShapeWindPtr then						DoShapeClear;				end;			PasteItem:				begin					if frontWindow=TerrainWindPtr then						DoTerrainPaste;					if frontWindow=ShapeWindPtr then						DoShapePaste;				end;			LoadItem:				begin					if frontWindow=TerrainWindPtr then						DoLoadTerrain;					if frontWindow=ShapeWindPtr then						DoLoadShape;					if frontWindow=EditorWindPtr then						DoLoadColors;				end;			LoadEverythingItem:				begin					DoLoadColors;					DoLoadTerrain;					DoLoadShape;				end;			QuitItem:				Done:=True;			AnalItem:				Anal;			LearnItem:				DoAnalyze;			ScaleUpItem:				begin					Scale:=Scale*2;					if scale > 32 then						Scale:=32					else						ChangeScale;				end;			ScaleDownItem:				begin					Scale:=Scale div 2;					if scale < 4 then						Scale:=4					else						ChangeScale;				end;			CreateItem:				Create;			EditorItem:				begin					showwindow(EditorWindPtr);					SelectWindow(EditorWindPtr);				end;			TerrainItem:				begin					showwindow(TerrainWindPtr);					SelectWindow(TerrainWindPtr);				end;			ShapeItem:				begin					showwindow(ShapeWindPtr);					SelectWindow(ShapeWindPtr);				end;			CycleItem:				begin					CycleOption:=not CycleOption;					CheckMItem(CycleOption,CycleItem);				end;			ChooserItem:				if PrChoosePrinter then					Dummy:=PRValidate(PrintHdl);      PageSetUpItem:				Dummy:=PRStlDialog(PrintHdl);      PrintItem:      	if frontWindow<>EditorWindPtr then					if PRJobDialog(PrintHdl) then	    			DoPrint;		end;		HiliteMenu(false,HiWord(Event.TaskData));	end;procedure mainEventLoop;	var		Event:EventRecord;		TheWindow:WindowPtr;			begin		event.TaskMask:=$1F7F;		Done:=False;		repeat			Case TaskMaster(-1,Event) of				NullEvent:					begin						if tool=2 then							drawselect;												if CycleOption and (TickCount-LastColorCycle>ColorCycleSpeed) then							begin								colorSetNumber:=(colorSetNumber+1) mod 16;								LastColorCycle:=TickCount;							end;						SetColorTable(0,Colors[ColorSetNumber]);													if (FindWindow(TheWindow,Event.Where.h,Event.Where.v)=WInContent) and (TheWindow=EditorWindPtr) then							begin								if TheCursor<>1 then	 								SetCursor(@CrossCursor);	 							TheCursor:=1;							end						else							if theCursor<>0 then								begin									initcursor;									thecursor:=0;								end;					end;				MouseDown:;				MouseUp:;				KeyDown:;				AutoKey:;				UpDateEvt:;				ActivateEvt:;				SwitchEvt:;				DeskaccEvt:;				wInDesk:;				winMenuBar:HandleWInMenuBar(Event);				wInContent:HandlewInContent(Event);				wInDrag:;				wInGrow:;				wInGoAway:HideWindow(WindowPtr(Event.TaskData));				wInZoom:;				wInInfo:HandlewInInfo(Event);				wInFrame:;			end;		until Done;	end;	Begin	StartUpGSTools;	SelectPatternNumber:=0;	LastColorCycle:=TickCount;	ColorCycleSpeed:=5;	Tool:=0;	GridOption:=1;	BrushSize:=1;	Scale:=32;	TheCursor:=0;	CycleOption:=false;	SetRect(SelectRect,0,0,0,0);	CopyRect:=SelectRect;	CopyShapeNumber:=0;		InitCursor;	SetUpCrossCursor;	SetUpMenus;	SetUpColors;	SetUpShapeOffScreen;	SetUpShapeWindow;	SetUpTerrainOffScreen;	SetUpTerrainWindow;	SetUpGridScreen;	SetUpTempPort;	SetUpEditorWindow;	MainEventLoop;		ShutDownGSTools;end.