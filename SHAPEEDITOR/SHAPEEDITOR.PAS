{$LongGlobals+}program ShapeEditor;uses		QDIntf,	GSIntf,		MiscTools,	ConsoleIO,	Prodos16,	FontMgr,	ListMgr,	PrintMgr,	ShapeUnit;procedure  DoLoadShape;		begin	with TypeList do		begin			NumEntries:=1;			FileType1:=$00;		end;	SFGetFile(50,20,'Load Shape File:',nil,@TypeList,MyReply);	if myReply.good then		begin			P16Blk.pathname2:=@myReply.fullpathname;			P16Blk.ioBuffer:=nil;			P16Open(P16Blk);			P16Blk.databuffer:=ShapeHandle^;			P16Blk.requestcount:=GetHandleSize(ShapeHandle);			P16Read(P16Blk);			P16Close(P16Blk);		end;	UpdateShapeOffscreen;	SetPort(ShapeWindPtr);	InvalRect(ShapeWindPtr^.PortRect);	SetPort(EditorWindPtr);	InvalRect(EditorWindPtr^.PortRect);	SetPort(TerrainWindPtr);	InvalRect(TerrainWindPtr^.PortRect);end;Procedure DoSaveShape;		  Begin   SFPutFile(50,20,'Save Shape as:','SHAPEE',15,myReply);   if myReply.good then   	begin			P16Blk.deletepathname:=@myReply.fullpathname;   		P16Destroy(P16Blk);   		P16Blk.pathname1:=@myReply.fullpathname;   		P16Blk.access:=$C3;   		P16Blk.fileType:=$00;   		P16Blk.auxType:=0;   		P16Blk.storageType:=1;   		P16Blk.CreateDate:=0;   		P16Blk.CreateTime:=0;   		P16Create(P16Blk);   		P16Blk.pathname2:=@myReply.fullpathname;   		P16Blk.ioBuffer:=nil;   		P16Open(P16Blk);   		P16Blk.databuffer:=ShapeHandle^;   		P16Blk.requestcount:=GetHandleSize(ShapeHandle);   		P16Write(P16Blk);   		P16Close(P16Blk);		end;end;  procedure  DoLoadcolors;		begin	with TypeList do		begin			NumEntries:=1;			FileType1:=$00;		end;	SFGetFile(50,20,'Load Color File:',nil,@TypeList,MyReply);	if myReply.good then		begin			P16Blk.pathname2:=@myReply.fullpathname;			P16Blk.ioBuffer:=nil;			P16Open(P16Blk);			P16Blk.databuffer:=@Colors;			P16Blk.requestcount:=sizeof(Colors);			P16Read(P16Blk);			P16Close(P16Blk);		end;	SetPort(ShapeWindPtr);	InvalRect(ShapeWindPtr^.PortRect);	SetPort(EditorWindPtr);	InvalRect(EditorWindPtr^.PortRect);	SetPort(TerrainWindPtr);	InvalRect(TerrainWindPtr^.PortRect);end;Procedure DoSaveColors;		  Begin   SFPutFile(50,20,'Save Colors as:','COLORS',15,myReply);   if myReply.good then   	begin			P16Blk.deletepathname:=@myReply.fullpathname;   		P16Destroy(P16Blk);   		P16Blk.pathname1:=@myReply.fullpathname;   		P16Blk.access:=$C3;   		P16Blk.fileType:=$00;   		P16Blk.auxType:=0;   		P16Blk.storageType:=1;   		P16Blk.CreateDate:=0;   		P16Blk.CreateTime:=0;   		P16Create(P16Blk);   		P16Blk.pathname2:=@myReply.fullpathname;   		P16Blk.ioBuffer:=nil;   		P16Open(P16Blk);   		P16Blk.databuffer:=@Colors;   		P16Blk.requestcount:=SizeOf(Colors);   		P16Write(P16Blk);   		P16Close(P16Blk);		end;end;procedure  DoLoadTerrain; begin	with TypeList do		begin			NumEntries:=1;			FileType1:=$00;		end;	SFGetFile(50,20,'Load Terrain File:',nil,@TypeList,MyReply);	if myReply.good then		begin			P16Blk.pathname2:=@myReply.fullpathname;			P16Blk.ioBuffer:=nil;			P16Open(P16Blk);			P16Blk.databuffer:=ptr(TerrainHandle^);			P16Blk.requestcount:=GetHandleSize(Handle(TerrainHandle));			P16Read(P16Blk);			P16Close(P16Blk);		end;	SetPort(TerrainWindPtr);	InvalRect(TerrainWindPtr^.PortRect);end;Procedure DoSaveTerrain;		  Begin   SFPutFile(50,20,'Save Terrain as:','TERRAIN',15,myReply);   if myReply.good then   	begin			P16Blk.deletepathname:=@myReply.fullpathname;   		P16Destroy(P16Blk);   		P16Blk.pathname1:=@myReply.fullpathname;   		P16Blk.access:=$C3;   		P16Blk.fileType:=$00;   		P16Blk.auxType:=0;   		P16Blk.storageType:=1;   		P16Blk.CreateDate:=0;   		P16Blk.CreateTime:=0;   		P16Create(P16Blk);   		P16Blk.pathname2:=@myReply.fullpathname;   		P16Blk.ioBuffer:=nil;   		P16Open(P16Blk);   		P16Blk.databuffer:=Ptr(TerrainHandle^);   		P16Blk.requestcount:=GetHandleSize(Handle(TerrainHandle));   		P16Write(P16Blk);   		P16Close(P16Blk);		end;  end;procedure DoAbout;var	aboutDlog:DialogPtr;	itemHit:integer;	r:Rect;  begin	setRect(r,20,30,300,170);	aboutDlog := NewModalDialog(r,true,0);	SetPort(aboutDlog);	SetRect(r,100,120,175,135);	SetBackColor(15);	SetForeColor(0);	NewDItem(aboutDlog,1,r,10,@' Okay ',0,0,nil);	SetDefButton(1,aboutDlog);	moveto(10,20);	DrawString('Terrain & Shape Editor v1.0');	SetForeColor(0);	moveto(10,50);	DrawString('  Written by:');	moveto(10,70);	DrawString('  Jim Surine');	moveto(10,80);	DrawString('  1995 W Kenwood Dr.');	moveto(10,90);	DrawString('  St Paul, MN 55117');	moveto(10,100);	DrawString('  (Using TML Pascal v1.5)');	SetForeColor(5);	moveto(10,110);	DrawString('  Dedicated to Amye.');		SetForeColor(0);  repeat		itemHit := ModalDialog(nil);	until itemHit	= 1;	CloseDialog(aboutDlog);end;Procedure DoPaste;	var		ShapeRect,		TempRect2:Rect;		i,j:integer;		begin	if FrontWindow<>TerrainWindPtr then		begin			SetRect(ShapeRect,0,0,32,32);			OffsetRect(ShapeRect,0,32*CopyShapeNumber);			SetPort(ShapePort);			PPtoPort(ShapePort^.PortInfo,ShapeRect,0,32*EditorShapeNumber,SrcCopy);			SetRect(TempRect2,0,0,scale,scale);			OffsetRect(TempRect2,EditorShapeNumber div 16 *scale,EditorShapeNumber mod 16*scale);			CopyPixels(ShapePort^.PortInfo,ShapeOffscreenPort^.PortInfo,ShapeRect,TempRect2,SrcCopy,ShapeOffscreenPort^.VisRgn);			OffsetRect(TempRect2,-HiWord(GetContentOrigin(ShapeWindPtr)),-LoWord(GetContentOrigin(ShapeWindPtr)));			CopyPixels(ShapePort^.PortInfo,ShapeWindPtr^.PortInfo,ShapeRect,TempRect2,SrcCopy,ShapeWindPtr^.VisRgn);			SetPort(EditorWindPtr);			InvalRect(EditorWindPtr^.PortRect);			SetPort(TerrainWindPtr);			InvalRect(TerrainWindPtr^.PortRect);		end	else		begin			for i:=TerrainCopyRect.Left to TerrainCopyRect.Right do					for j:=TerrainCopyRect.Top to TerrainCopyRect.Bottom do						TerrainHandle^^[j+TerrainPastePoint.v-TerrainCopyRect.top,i+TerrainPastePoint.h-TerrainCopyRect.Left]:=TerrainHandle^^[j,i];			SetPort(TerrainWindPtr);			InvalRect(TerrainWindPtr^.PortRect);		end;end;procedure PrintTerrain;  var    myPrPort:TPPrport;    ThePort:WindowPtr; 		ShapeRect,		TempRect,		DestRect,		PortRect:Rect;		i,j:integer;		begin		myPrPort := PrOpenDoc(PrintHdl,nil);		PrOpenPage(myPrPort,nil);		SetRect(ShapeRect,0,0,scale,scale);		GetPortRect(PortRect);		ThePort:=GetPort;		for i:= 0 to PortRect.right div scale + 1 do			for j:=0 to PortRect.bottom div scale + 1 do				begin					TempRect:=ShapeRect;					OffsetRect(TempRect,TerrainHandle^^[j,i] div 16 *scale,TerrainHandle^^[j,i] mod 16 *scale);					PPtoPort(ShapeOffscreenPort^.PortInfo,TempRect,i*scale,j*scale,SrcCopy);				end;		PrClosePage(myPrPort);		PrCloseDoc(myPrPort);		PrPicFile(PrintHdl,nil,nil);  end;  procedure DoFlipVert;  	var 		Storage:Array [0..31,0..31] of integer; 		i,j:integer; 	 	begin 		SetPort(ShapePort); 		for i:=0 to 31 do 			for j:=0 to 31 do 				Storage[i,j]:=GetPixel(i,j+EditorShapeNumber*32); 		 		for i:=0 to 31 do 			for j:=0 to 31 do				begin					SetSolidPenPat(Storage[i,31-j]);					moveto(i,j+EditorShapeNumber*32);					line(0,0);				end;				UpdateShapeOffscreen;		SetPort(ShapeWindPtr);		InvalRect(ShapeWindPtr^.PortRect);		SetPort(EditorWindPtr);		InvalRect(EditorWindPtr^.PortRect);		SetPort(TerrainWindPtr);		InvalRect(TerrainWindPtr^.PortRect); 	end; 	 procedure DoFlipHorz;  	var 		Storage:Array [0..31,0..31] of integer; 		i,j:integer; 	 	begin		SetPort(ShapePort);  	for i:=0 to 31 do 			for j:=0 to 31 do 				Storage[i,j]:=GetPixel(i,j+EditorShapeNumber*32); 		 		for i:=0 to 31 do 			for j:=0 to 31 do				begin					SetSolidPenPat(Storage[31-i,j]);					moveto(i,j+EditorShapeNumber*32);					line(0,0);				end;								UpdateShapeOffscreen;		SetPort(ShapeWindPtr);		InvalRect(ShapeWindPtr^.PortRect);		SetPort(EditorWindPtr);		InvalRect(EditorWindPtr^.PortRect);		SetPort(TerrainWindPtr);		InvalRect(TerrainWindPtr^.PortRect); 	end; procedure DoMoveLeft;  	var 		Storage:Array [0..31,0..31] of integer; 		i,j:integer; 	 	begin		SetPort(ShapePort);  	for i:=0 to 31 do 			for j:=0 to 31 do 				Storage[i,j]:=GetPixel(i,j+EditorShapeNumber*32); 		 		for i:=0 to 31 do 			for j:=0 to 31 do				begin					SetSolidPenPat(Storage[(i+1) mod 32,j]);					moveto(i,j+EditorShapeNumber*32);					line(0,0);				end;								UpdateShapeOffscreen;		SetPort(ShapeWindPtr);		InvalRect(ShapeWindPtr^.PortRect);		SetPort(EditorWindPtr);		InvalRect(EditorWindPtr^.PortRect);		SetPort(TerrainWindPtr);		InvalRect(TerrainWindPtr^.PortRect); 	end; 	 procedure DoMoveUp;  	var 		Storage:Array [0..31,0..31] of integer; 		i,j:integer; 	 	begin		SetPort(ShapePort);  	for i:=0 to 31 do 			for j:=0 to 31 do 				Storage[i,j]:=GetPixel(i,j+EditorShapeNumber*32); 		 		for i:=0 to 31 do 			for j:=0 to 31 do				begin					SetSolidPenPat(Storage[i,(j+1) mod 32]);					moveto(i,j+EditorShapeNumber*32);					line(0,0);				end;								UpdateShapeOffscreen;		SetPort(ShapeWindPtr);		InvalRect(ShapeWindPtr^.PortRect);		SetPort(EditorWindPtr);		InvalRect(EditorWindPtr^.PortRect);		SetPort(TerrainWindPtr);		InvalRect(TerrainWindPtr^.PortRect); 	end;  procedure ChangeScale(OldScale,NewScale:integer); 	begin		Scale:=NewScale;		UpdateShapeOffscreen;		SetPort(TerrainWindPtr);		InvalRect(TerrainWindPtr^.portRect);		SetPort(ShapeWindPtr);		InvalRect(ShapeWindPtr^.portRect);		SetPage(NewScale*4,NewScale*4,TerrainWindPtr);		SetScroll(NewScale,NewScale,TerrainWindPtr);		SetDataSize(NewScale*256,NewScale*256,TerrainWindPtr);		SetContentOrigin(HiWord(GetContentOrigin(TerrainWindPtr)) div OldScale * NewScale,LoWord(GetContentOrigin(TerrainWindPtr)) div OldScale * NewScale,TerrainWindPtr);		SetPage(NewScale*4,NewScale*4,ShapeWindPtr);		SetScroll(NewScale,NewScale,ShapeWindPtr);		SetDataSize(NewScale*16,NewScale*16,ShapeWindPtr);		SetContentOrigin(HiWord(GetContentOrigin(ShapeWindPtr)) div OldScale * NewScale,LoWord(GetContentOrigin(ShapeWindPtr)) div OldScale * NewScale,ShapeWindPtr);	end;procedure ProcessMenu(Event:EventRecord);	var		Dummy:Boolean;			begin		case LoWord(Event.TaskData) of			Aboutitem:				DoAbout;			LoadShapeItem:				DoLoadShape;			SaveTerrainItem:				DoSaveTerrain;			LoadColorItem:				DoLoadColors;			SaveColorItem:				DoSaveColors;			LoadTerrainItem:				DoLoadTerrain;			SaveShapeItem:				DoSaveSHape;			ChooserItem:				if PrChoosePrinter then					Dummy:=PRValidate(PrintHdl);      PageSetUpItem:				Dummy:=PRStlDialog(PrintHdl);      PrintItem:				if PRJobDialog(PrintHdl) then	    		PrintTerrain;			QuitItem:				Done:=True;			CopyItem:				if FrontWindow<>TerrainWindPtr then					CopyShapeNumber:=EditorShapeNumber;			CutItem:				if FrontWindow<>TerrainWindPtr then					CopyShapeNumber:=EditorShapeNumber;			PasteItem:				DoPaste;			PaletteItem:				begin					showwindow(PaletteWindPtr);					SelectWindow(PaletteWindPtr);				end;			ShapeItem:				begin					showwindow(ShapeWindPtr);					SelectWindow(ShapeWindPtr);				end;			CritterItem:				begin					showwindow(CritterWindPtr);					SelectWindow(CritterWindPtr);				end;			PaletteEditorItem:				begin					showwindow(PaletteEditorWindPtr);					SelectWindow(PaletteEditorWindPtr);				end;			AnimationEditorItem:				begin					showwindow(AnimationEditorWindPtr);					SelectWindow(AnimationEditorWindPtr);				end;			AnimationOptionItem:				begin					AnimationOption:=not AnimationOption;					CheckMItem(AnimationOption,AnimationOptionItem);				end;			EditorItem:				begin					showwindow(EditorWindPtr);					SelectWindow(EditorWindPtr);				end;			TerrainItem:				begin					showwindow(TerrainWindPtr);					SelectWindow(TerrainWindPtr);				end;			GridItem:				begin					GridOption:=not GridOption;					CheckMItem(GridOption,GridItem);					SetPort(EditorWindPtr);					invalRect(EditorWindPtr^.PortRect);				end;			CycleItem:				begin					CycleOption:=not CycleOption;					CheckMItem(CycleOption,CycleItem);				end;			BigBrushItem:				begin					BrushSize:=4-BrushSize;				end;			CoordItem:				begin					Coord:=not coord;					CheckMItem(Coord,CoordItem);				end;			flipHorzItem:				DoFlipHorz;			flipVertItem:				DoFlipVert;			MoveLeftItem:				DoMoveLeft;			MoveUpItem:				DoMoveUp;			QuarterScaleItem:				ChangeScale(Scale,8);			HalfScaleItem:				ChangeScale(Scale,16);			FullScaleItem:				ChangeScale(Scale,32);			HideWindowItem:				HideWindow(FrontWindow);		end;				HiliteMenu(false,HiWord(Event.TaskData));	end;procedure HandlewInContent(Event:EventRecord);	var		TempRect,		TempRect2,		ShapeRect,		DestRect:rect;		TempStr:Str255;		Part,currvalue,i:integer;		TheControl:ControlHandle;		begin	if windowptr(Event.TaskData)=PaletteWindPtr then		begin			SetPort(PaletteWindPtr);			GlobalToLocal(Event.Where);			PaletteColorNumber:=Event.Where.h div 16;			invalRect(PaletteWindPtr^.PortRect);			SetPort(PaletteEditorWindPtr);			invalRect(PaletteEditorWindPtr^.PortRect);						if bitAnd(Event.Modifiers,AppleKey)<>0 then				begin					SetPort(ShapePort);					SetSolidPenPat(PaletteColorNumber);					SetRect(ShapeRect,0,0,32,32);					OffsetRect(ShapeRect,0,EditorShapeNumber*32);					PaintRect(ShapeRect);					SetPort(ShapeWindPtr);					InvalRect(ShapeWindPtr^.PortRect);					SetPort(EditorWindPtr);					InvalRect(EditorWindPtr^.PortRect);					SetPort(TerrainWindPtr);					InvalRect(TerrainWindPtr^.PortRect);				end;			if bitAnd(Event.Modifiers,OptionKey)<>0 then				for i:=0 to 15 do					Colors[i,PaletteColorNumber]:=Colors[GetCtlValue(PaletteScrollArray[4]),PaletteColorNumber];		end;			if windowptr(Event.TaskData)=ShapeWindPtr then		begin			SetPort(ShapeWindPtr);			GlobalToLocal(Event.Where);			SetRect(ShapeRect,0,0,32,32);			OffsetRect(ShapeRect,0,32*EditorShapeNumber);			SetRect(DestRect,0,0,scale,scale);			OffsetRect(DestRect,EditorShapeNumber div 16 *scale-HiWord(GetContentOrigin(ShapeWindPtr)),EditorShapeNumber mod 16*scale-LoWord(GetContentOrigin(ShapeWindPtr)));						CopyPixels(ShapePort^.PortInfo,ShapeWindPtr^.PortInfo,ShapeRect,DestRect,SrcCopy,ShapeWindPtr^.VisRgn);						EditorShapeNumber:=(Event.Where.h+HiWord(GetContentOrigin(ShapeWindPtr))) div Scale  *16+ (Event.Where.v +LoWord(GetContentOrigin(ShapeWindPtr))) div Scale ;			SetRect(DestRect,0,0,scale,scale);			OffsetRect(DestRect,EditorShapeNumber div 16 *scale-HiWord(GetContentOrigin(ShapeWindPtr)),EditorShapeNumber mod 16*scale-LoWord(GetContentOrigin(ShapeWindPtr)));						SetSolidPenPat(0);			FrameRect(DestRect);			SetPort(EditorWindPtr);			invalRect(EditorWindPtr^.PortRect);			CritterOption:=False;		end;	if windowptr(Event.TaskData)=CritterWindPtr then		begin			SetPort(CritterWindPtr);			GlobalToLocal(Event.Where);			SetRect(ShapeRect,0,0,32,32);			OffsetRect(ShapeRect,0,32*CritterShapeNumber);			SetRect(DestRect,0,0,scale,scale);			OffsetRect(DestRect,CritterShapeNumber div 16 *scale-HiWord(GetContentOrigin(CritterWindPtr)),CritterShapeNumber mod 16*scale-LoWord(GetContentOrigin(CritterWindPtr)));						CopyPixels(CritterPort^.PortInfo,CritterWindPtr^.PortInfo,ShapeRect,DestRect,SrcCopy,CritterWindPtr^.VisRgn);						CritterShapeNumber:=(Event.Where.h+HiWord(GetContentOrigin(CritterWindPtr))) div Scale  *16+ (Event.Where.v +LoWord(GetContentOrigin(CritterWindPtr))) div Scale ;			SetRect(DestRect,0,0,scale,scale);			OffsetRect(DestRect,CritterShapeNumber div 16 *scale-HiWord(GetContentOrigin(CritterWindPtr)),CritterShapeNumber mod 16*scale-LoWord(GetContentOrigin(CritterWindPtr)));						SetSolidPenPat(0);			FrameRect(DestRect);			SetPort(EditorWindPtr);			invalRect(EditorWindPtr^.PortRect);						CritterOption:=True;		end;			if windowptr(Event.TaskData)=TerrainWindPtr then		begin			SetRect(ShapeRect,0,0,scale,scale);			SetPort(TerrainWindPtr);			GlobaltoLocal(Event.Where);			if bitAnd(Event.Modifiers,AppleKey+ShiftKey+optionKey)=0 then				while StillDown(0) do					begin						if ptinRect(Event.Where,TerrainWindPtr^.PortRect) then							begin								TerrainHandle^^[(Event.Where.v+ LoWord(GetContentOrigin(TerrainWindPtr))) div Scale,(Event.Where.h+HiWord(GetContentOrigin(TerrainWindPtr))) div Scale]:=EditorShapeNumber;								TempRect:=ShapeRect;								OffsetRect(TempRect,EditorShapeNumber div 16 *scale,EditorShapeNumber mod 16 *scale);								PPtoPort(ShapeOffscreenPort^.PortInfo,TempRect,(Event.Where.h+HiWord(GetContentOrigin(TerrainWindPtr))) div Scale *Scale-HiWord(GetContentOrigin(TerrainWindPtr))								,(Event.Where.v+LoWord(GetContentOrigin(TerrainWindPtr))) div Scale*Scale-LoWord(GetContentOrigin(TerrainWindPtr)),SrcCopy);							end;						GetMouse(Event.Where);					end			else				if bitAnd(Event.Modifiers,AppleKey)<>0 then					begin						TerrainPastePoint.h:=(Event.Where.h+HiWord(GetContentOrigin(TerrainWindPtr))) div 32;						TerrainPastePoint.v:=(Event.Where.v+LoWord(GetContentOrigin(TerrainWindPtr))) div 32;						SetPort(TerrainWindPtr);						InvalRect(TerrainWindPtr^.PortRect);					end				else					if bitAnd(Event.Modifiers,OptionKey)<>0 then						begin							TerrainCopyRect.Left:=(Event.Where.h+HiWord(GetContentOrigin(TerrainWindPtr))) div 32;							TerrainCopyRect.Top:=(Event.Where.v+LoWord(GetContentOrigin(TerrainWindPtr))) div 32;											SetPort(TerrainWindPtr);							InvalRect(TerrainWindPtr^.PortRect);						end					else						if bitAnd(Event.Modifiers,ShiftKey)<>0 then							begin								TerrainCopyRect.Right:=(Event.Where.h+HiWord(GetContentOrigin(TerrainWindPtr))) div 32;								TerrainCopyRect.Bottom:=(Event.Where.v+LoWord(GetContentOrigin(TerrainWindPtr))) div 32;												SetPort(TerrainWindPtr);								InvalRect(TerrainWindPtr^.PortRect);							end;		end;		if windowptr(Event.TaskData)=PaletteEditorWindPtr then		begin			part:=FindControl(theControl,Event.where.h,Event.where.v,windowptr(Event.TaskData));			if theControl <> nil then				begin					if part =$81 then						part:=TrackControl(Event.where.h,Event.where.v,nil,theControl);					currValue:=GetCtlValue(theControl);					case part of					5:if currValue > 0 then						SetCtlValue(currValue - 1,theControl);					6:if currValue < 15 then						SetCtlValue(currValue + 1,theControl);					7:						begin							currValue := currValue - 2;							if currValue < 0 then									currValue := 0;							SetCtlValue(currValue,theControl);						end;					8:						begin							currValue := currValue + 2;							if currValue > 15 then 								currValue := 15;							SetCtlValue(currValue,theControl);						end;    		end;    			if theControl<>PaletteScrollArray[4] then						Colors[GetCtlValue(PaletteScrollArray[4]),PaletteColorNumber]:=GetCtlValue(PaletteScrollArray[1])+GetCtlValue(PaletteScrollArray[2])*$10+GetCtlValue(PaletteScrollArray[3])*$100					else						begin							ColorSetNumber:=GetCtlValue(PaletteScrollArray[4]);							SetPort(PaletteEditorWindPtr);							InvalRect(PaletteEditorWindPtr^.PortRect);						end;					ColorCycleSpeed:=GetCtlValue(PaletteScrollArray[5]);				end;		end;	if windowptr(Event.TaskData)=AnimationEditorWindPtr then		begin			part:=FindControl(theControl,Event.where.h,Event.where.v,windowptr(Event.TaskData));			if theControl <> nil then				begin					if part =$81 then						part:=TrackControl(Event.where.h,Event.where.v,nil,theControl);					currValue:=GetCtlValue(theControl);					case part of					5:if currValue > 0 then						SetCtlValue(currValue - 1,theControl);					6:if currValue < 15 then						SetCtlValue(currValue + 1,theControl);					7:						begin							currValue := currValue - 2;							if currValue < 0 then									currValue := 0;							SetCtlValue(currValue,theControl);						end;					8:						begin							currValue := currValue + 2;							if currValue > 15 then 								currValue := 15;							SetCtlValue(currValue,theControl);						end;    		end;					SetPort(AnimationEditorWindPtr);					invalRect(AnimationEditorWindPtr^.PortRect);				end;		end;					if windowptr(Event.TaskData)=EditorWindPtr then		begin			SetRect(ShapeRect,0,0,4*brushSize,4*brushSize);							SetRect(DestRect,0,0,32,32);			if CritterOption then				begin					OffsetRect(DestRect,0,32*CritterShapeNumber);					SetPort(CritterPort);				end			else				begin					OffsetRect(DestRect,0,32*EditorShapeNumber);					SetPort(ShapePort);				end;			ClipRect(DestRect);			SetRect(DestRect,0,0,Scale,Scale);			if CritterOption then				begin					OffsetRect(DestRect,CritterShapeNumber div 16 *Scale-HiWord(GetContentOrigin(CritterWindPtr)),CritterShapeNumber mod 16 *Scale-LoWord(GetContentOrigin(CritterWindPtr)));					SetPort(CritterWindPtr);				end			else				begin					OffsetRect(DestRect,EditorShapeNumber div 16 *Scale-HiWord(GetContentOrigin(ShapeWindPtr)),EditorShapeNumber mod 16 *Scale-LoWord(GetContentOrigin(ShapeWindPtr)));					SetPort(ShapeWindPtr);				end;			ClipRect(DestRect);			SetRect(DestRect,0,0,brushSize,brushSize);			SetPort(EditorWindPtr);			GlobaltoLocal(Event.Where);			while StillDown(0) do				begin					if ptinRect(Event.Where,EditorWindPtr^.PortRect) then						begin							TempRect:=ShapeRect;							OffsetRect(TempRect,Event.Where.h div 4*4,Event.Where.v div 4*4);							SetSolidPenPat(PaletteColorNumber);							PaintRect(TempRect);							if GridOption then								PPtoPort(GridPort^.PortInfo,TempRect,TempRect.left,TempRect.top,NotSrcBic);														if CritterOption then								begin							SetPort(CritterWindPtr);							SetSolidPenPat(PaletteColorNumber);							TempRect:=destRect;							OffsetRect(TempRect,Event.Where.h div (128 div scale)+CritterShapeNumber div 16 * scale-HiWord(GetContentOrigin(CritterWindPtr)),Event.Where.v div (128 div scale) +CritterShapeNumber mod 16 * scale-LoWord(GetContentOrigin(CritterWindPtr)));							PaintRect(TempRect);												SetPort(CritterPort);							SetSolidPenPat(PaletteColorNumber);							TempRect:=destRect;							OffsetRect(TempRect,Event.Where.h div 4,Event.Where.v div 4+CritterShapeNumber*32);							PaintRect(TempRect);								end							else								begin							SetPort(ShapeWindPtr);							SetSolidPenPat(PaletteColorNumber);							TempRect:=destRect;							OffsetRect(TempRect,Event.Where.h div (128 div scale)+EditorShapeNumber div 16 * scale-HiWord(GetContentOrigin(ShapeWindPtr)),Event.Where.v div (128 div scale) +EditorShapeNumber mod 16 * scale-LoWord(GetContentOrigin(ShapeWindPtr)));							PaintRect(TempRect);												SetPort(ShapePort);							SetSolidPenPat(PaletteColorNumber);							TempRect:=destRect;							OffsetRect(TempRect,Event.Where.h div 4,Event.Where.v div 4+EditorShapeNumber*32);							PaintRect(TempRect);															end;														if Coord then								begin									SetPort(GetMenuMgrPort);									TempStr:=IntToString(Event.Where.h div 4);									SetTextMode(SrcCopy);									moveto(260,10);									DrawString('X:');									DrawString(TempStr);									DrawString(' Y:');									TempStr:=IntToString(Event.Where.v div 4);									DrawString(TempStr);									DrawString('  ');								end;						end;					SetPort(EditorWindPtr);					GetMouse(Event.Where);				end;			if critterOption then				begin					SetPort(CritterPort);					SetRect(TempRect,0,0,32,256*32);					ClipRect(TempRect);					SetPort(CritterWindPtr);					SetRect(TempRect,0,0,16*32,16*32);					ClipRect(TempRect);				end			else				begin					SetRect(TempRect,0,0,32,32);					SetRect(TempRect2,0,0,scale,scale);					OffsetRect(TempRect,0,32*EditorShapeNumber);					OffsetRect(TempRect2,EditorShapeNumber div 16 *scale,EditorShapeNumber mod 16*scale);					CopyPixels(ShapePort^.PortInfo,ShapeOffscreenPort^.PortInfo,TempRect,TempRect2,SrcCopy,ShapeOffscreenPort^.VisRgn);					OffsetRect(TempRect2,-HiWord(GetContentOrigin(ShapeWindPtr)),-LoWord(GetContentOrigin(ShapeWindPtr)));					CopyPixels(ShapePort^.PortInfo,ShapeWindPtr^.PortInfo,TempRect,TempRect2,SrcCopy,ShapeWindPtr^.VisRgn);										SetPort(ShapePort);					SetRect(TempRect,0,0,32,256*32);					ClipRect(TempRect);					SetPort(ShapeWindPtr);					SetSolidPenPat(0);					FrameRect(TempRect2);					SetRect(TempRect,0,0,16*32,16*32);					ClipRect(TempRect);				end;			SetPort(TerrainWindPtr);			invalRect(terrainWindPtr^.PortRect);		end;end;	procedure mainEventLoop;	var		Event:EventRecord;		TempStr:Str255;		TheWindow:WindowPtr;		infoRect:Rect;			begin		event.TaskMask:=$1F7F;				Done:=False;				repeat			Case TaskMaster(-1,Event) of				NullEvent:					begin					if CycleOption and (TickCount-LastColorCycle>ColorCycleSpeed) then						begin							colorSetNumber:=(colorSetNumber+1) mod 16;							LastColorCycle:=TickCount;						end;										if AnimationOption and (TickCount-LastAnimation>AnimationSpeed) then						begin							AnimationSequence:=(AnimationSequence+1) mod 16;							LastAnimation:=TickCount;						end;											SetColorTable(0,Colors[ColorSetNumber]);											if (FindWindow(TheWindow,Event.Where.h,Event.Where.v)=WInContent) and (TheWindow=EditorWindPtr) then						begin							if TheCursor<>1 then	 							SetCursor(@CrossCursor);	 						TheCursor:=1;							SetPort(EditorWindPtr);							GlobalToLocal(Event.Where);															SetPort(GetMenuMgrPort);							TempStr:=IntToString(Event.Where.h div 4);							moveto(260,10);							SetTextMode(SrcCopy);							DrawString('X:');							DrawString(TempStr);							DrawString(' Y:');							TempStr:=IntToString(Event.Where.v div 4);							DrawString(TempStr);							DrawString('   ');						end					else						if theCursor<>0 then							begin								initcursor;								thecursor:=0;							end;					end;				MouseDown:;				MouseUp:;				KeyDown:;				AutoKey:;				UpDateEvt:;				ActivateEvt:;				SwitchEvt:;				DeskaccEvt:;				wInDesk:;				winMenuBar:ProcessMenu(Event);				wInContent:HandlewInContent(Event);				wInDrag:;				wInGrow:;				wInGoAway:;				wInZoom:;				wInInfo:;				wInFrame:;			end;		until Done;	end;Begin	GridOption:=False;	EditorShapeNumber:=0;	CopyShapeNumber:=0;	PaletteColorNumber:=0;	SetRect(TerrainCopyRect,0,0,0,0);	SetPt(TerrainPastePoint,0,0);	TheCursor:=0;	Scale:=32;	BrushSize:=1;	Coord:=False;	ColorSetNumber:=0;	cycleOption:=False;	CritterOption:=False;	CritterShapeNumber:=0;	LastColorCycle:=TickCount;	ColorCycleSpeed:=5;	AnimationNumber:=0;	AnimationOption:=false;	AnimationSequence:=0;	AnimationSpeed:=0;	LastAnimation:=TickCount;		StartUpGSTools;	SetUpMenus;	SetUpCrossCursor;	SetUpGridScreen;	SetUpShapeOffScreen;	SetUpTerrainOffScreen;	SetUpShapeWindow;	SetUpColors;	SetUpPaletteEditorWindow;	SetUpTerrainWindow;	SetUpEditorWindow;	SetUpPaletteWindow;	SetUpCritterWindow;	SetUpCritterOffScreen;	SetUpCritterDefinition;	{SetUpAnimationEditorWindow;}	InitCursor;		MainEventLoop;		ShutDownGSTools;end.