         keep  /apw.code/arcade.code/shape.e         mcopy /apw.code/arcade.code/arcade.macros         copy  /apw.code/arcade.code/globals.asmInitShape start         using GSOSParam         using Shape         using ShapeData;load shape bitmap         lda   #ShapePath               init GSOSParam         sta   path         lda   #^ShapePath         sta   path+2         lda   #$20000         sta   count         lda   #^$20000         sta   count+2         lda   #Shape         sta   buf         lda   #^Shape         sta   buf+2         jsr   ReadFile;load shape table         lda   #ShapeTablePath               init GSOSParam         sta   path         lda   #^ShapeTablePath         sta   path+2         lda   #$1E00         sta   count         lda   #^$1E00         sta   count+2         lda   #ShapeData         sta   buf         lda   #^ShapeData         sta   buf+2;        jsr   ReadFile;fix all shape and mask addresses         ldx   #0loop     lda   ShapeAddress1List,x         clc         adc   #Shape         sta   ShapeAddress1List,x         lda   ShapeAddress2List,x         adc   #^Shape         sta   ShapeAddress2List,x         lda   MaskAddress1List,x         clc         adc   #Shape         sta   MaskAddress1List,x         lda   MaskAddress2List,x         adc   #^Shape         sta   MaskAddress2List,x         inx         inx         cpx   #2*16         bne   loop         rtsShapePath str  'shape'ShapeTablePath str 'shape.table'         endProcessShape start         using MultBy160         using DrawPage         using ShapeData         using Shape;draw a shape on the terrain, clip it and draw it so it can be removed;get shape number         lda   ShapeNumber         asl   a         tax;move data from shape data list to direct page for fast access         lda   ShapeAddress1List,x         sta   ShapeAddress         lda   ShapeAddress2List,x         sta   ShapeAddress+2         lda   MaskAddress1List,x         sta   MaskAddress         lda   MaskAddress2List,x         sta   MaskAddress+2         lda   ShapeStartXList,x         sta   ShapeStartX         lda   ShapeStartYList,x         sta   ShapeStartY         lda   ShapeDrawWidthList,x         sta   ShapeDrawWidth         lda   ShapeDrawHeightList,x         sta   ShapeDrawHeight         lda   ShapeWidthList,x         sta   ShapeWidth         lda   ShapeHeightList,x         sta   ShapeHeight;convert from terrain coordinates to terrain screen coordinates         lda   ShapeX         sec         sbc   TerrainX         bpl   skip1         lsr   a         lsr   a         lsr   a         lsr   a         ora   #$F000                   make negative         and   #$FFFE                   only even bytes         bra   cont1skip1    lsr   a         lsr   a         lsr   a         lsr   a         and   #$FFFE                   only even bytescont1    sta   ShapeX         lda   ShapeY         sec         sbc   TerrainY         bpl   skip2         lsr   a         lsr   a         lsr   a         ora   #$E000                   make nagative         bra   cont2skip2    lsr   a         lsr   a         lsr   acont2    sta   ShapeY;clip shape to terrain screenCheckX1  lda   ShapeX         cmp   #TerrainScreenWidth         bge   CheckX2         clc         adc   ShapeDrawWidth         cmp   #TerrainScreenWidth         blt   CheckY1         lda   #TerrainScreenWidth         sec         sbc   ShapeX         sta   ShapeDrawWidth         bra   CheckY1CheckX2  clc         adc   ShapeDrawWidth         beq   exit         cmp   #TerrainScreenWidth         bge   Exit         sta   ShapeDrawWidth         lda   ShapeX         eor   #$FFFF         inc   a         clc         adc   ShapeStartX         sta   ShapeStartX         stz   ShapeXCheckY1  lda   ShapeY         cmp   #TerrainScreenHeight         bge   CheckY2         clc         adc   ShapeDrawHeight         cmp   #TerrainScreenHeight         blt   OK         lda   #TerrainScreenHeight         sec         sbc   ShapeY         sta   ShapeDrawHeight         bra   OKCheckY2  clc         adc   ShapeDrawHeight         beq   Exit         cmp   #TerrainScreenHeight         bge   Exit         sta   ShapeDrawHeight         lda   ShapeY         eor   #$FFFF         inc   a         clc         adc   ShapeStartY         sta   ShapeStartY         stz   ShapeY         bra   okexit     rts                            shape offscreen, do not drawok       anop;convert from terrain screen coordinates to draw page coordinates         lda   ShapeX         clc         adc   #TerrainScreenX         sta   ShapeX         lda   ShapeY         clc         adc   #TerrainScreenY         sta   ShapeY;save draw page under shape to buffer, AND mask, OR shape to draw page;Y = ShapeX + ShapeY * 160         lda   ShapeY         asl   a         tax         lda   ShapeX         clc         adc   MultBy160,x         tay                            save A in Y;ShapeCheckDone = Y + ShapeDrawHeight * 160         lda   ShapeDrawHeight         asl   a         tax         tya                            restore A from Y         clc         adc   MultBy160,x         sta   ShapeCheckDone;X = Y         tyx;ShapeDrawPageStep = DrawPageWidth - ShapeDrawWidth         lda   #DrawPageWidth           must be even         sec         sbc   ShapeDrawWidth           must by even         sta   ShapeDrawPageStep;AddressStep = ShapeWidth - ShapeDrawWidth         lda   ShapeWidth               must be even         sec         sbc   ShapeDrawWidth           must be even         sta   AddressStep;Y = ShapeStartX + ShapeWidth * ShapeStartY         lda   #0                       product = 0         ldy   #16                      count =16 (16 bit multiply)mult     lsr   ShapeWidth         bcc   chcnt                    is carry from multiplier         clc         adc   ShapeStartY              yes, product = product + multiplicandchcnt    asl   ShapeStartY         dey         bne   mult         clc         adc   ShapeStartX              add X         tay                            save in Y         phb                            save data bank register         lda   #^DrawPage               move data bank to draw page         pha         plbloop1    lda   ShapeDrawWidth           ShapeCount = ShapeDrawWidth/2         lsr   a         sta   ShapeCountloop2    anop         lda   |DrawPage,x              get under         sta   (DrawPageStorage)        save under         and   [MaskAddress],y          AND mask         ora   [ShapeAddress],y         OR shape         sta   |DrawPage,x              replace         inc   DrawPageStorage         inc   DrawPageStorage         inx         inx         iny         iny         dec   ShapeCount         bne   Loop2         txa         sta   (AddressStorage)         inc   AddressStorage         inc   AddressStorage         lda   ShapeDrawWidth         sta   (LengthStorage)         inc   LengthStorage         inc   LengthStorage         tya         clc         adc   AddressStep         tay         txa         clc         adc   ShapeDrawPageStep         tax         cpx   ShapeCheckDone         blt   loop1         plb         plb                            restore data bank register         rts         endEraseShapes start         using DrawPage;remove all shapes from drawpage that were drawn above         phb                            save direct page         lda   #^DrawPage               move direct page to draw page         pha         plbloop1    lda   AddressStorage         cmp   #AddressStorageLoc         beq   exit         dec   a         dec   a         sta   AddressStorage         dec   LengthStorage         dec   LengthStorage         lda   (LengthStorage)         tay         lda   DrawPageStorage         sec         sbc   (LengthStorage)         sta   DrawPageStorage         lda   (AddressStorage)         taxloop2    dex         dex         dey         dey         lda   (DrawPageStorage),y         sta   |DrawPage,x         cpy   #0         bne   loop2         bra   loop1exit     plb         plb                            restore direct page;drops through and inits storage for reuseInitEraseShapes entry;reset storage variables         lda   #DrawPageStorageLoc         sta   DrawPageStorage         lda   #AddressStorageLoc         sta   AddressStorage         lda   #LengthStorageLoc         sta   LengthStorage         rts         endAddToShapeList start         using ShapeData         using ShapeListData;Add the shape to the shape list to be drawn later and checked for intersections         ldx   NumberInShapeList         cpx   #256*2         bne   ok         rtsok       lda   ShapePriority         sta   ShapePrioritylist,x         cmp   MaxShapePriority         blt   skip         sta   MaxShapePriorityskip     anop         lda   ShapeClass         sta   ShapeClassList,x         lda   ShapeNumber         sta   ShapeNumberList,x         asl   a         tay         lda   ShapeX         sta   ShapeXlist,x         clc         adc   ShapeCollisionXOffsetList,y         sta   ShapeCollisionXlist,x         lda   ShapeY         sta   ShapeYlist,x         clc         adc   ShapeCollisionYOffsetList,y         sta   ShapeCollisionYlist,x         lda   ShapeDataCollisionWidthList,y         sta   ShapeCollisionWidthList,x         lda   ShapeDataCollisionHeightList,y         sta   ShapeCollisionHeightList,x         lda   ShapeDataTypeList,y         sta   ShapeTypeList,x         inc   NumberInShapeList         inc   NumberInShapeList         rts         endProcessShapeList start         using ShapeListData         using ShapeData;process all shapes in shape list; draw, intersection, and reset         lda   NumberInShapeList         beq   exit         inc   MaxShapePriority         ldy   #00                      priority zeroloop1    ldx   #00                      first in listloop2    tya         cmp   ShapePrioritylist,x         bne   skip         lda   ShapeNumberlist,x         sta   ShapeNumber         lda   ShapeXlist,x         sta   ShapeX         lda   ShapeYlist,x         sta   ShapeY         phx         phy         jsr   ProcessShape         ply         plxskip     inx         inx         cpx   NumberInShapeList         bne   loop2         iny         cpy   MaxShapePriority         check for last priority         bne   loop1         bra   exit;now check all intersections         lda   NumberInShapeList         cmp   #2         bge   start1exit     brl   InitShapeListstart1   ldx   #0loop3    txy         iny         iny         lda   ShapeClassList,x         cmp   ShapeClassList,y         beq   gono         lda   ShapeCollisionXlist,x         sta   ShapeCollisionX         lda   ShapeCollisionYlist,x         sta   ShapeCollisionY         lda   ShapeCollisionWidthlist,x         asl   a         asl   a         asl   a         asl   a         dec   a         sta   ShapeCollisionWidth         lda   ShapeCollisionHeightlist,x         asl   a         asl   a         asl   a         dec   a         sta   ShapeCollisionHeightcheckX1  lda   ShapeCollisionX         cmp   ShapeCollisionXlist,y         bge   checkX2         clc         adc   ShapeCollisionWidth         cmp   ShapeCollisionXlist,y         bge   checkY1         lda   ShapeCollisionWidthList,y         asl   a         asl   a         asl   a         asl   a         dec   a         clc         adc   ShapeCollisionXlist,y         cmp   ShapeCollisionXList,y         bge   gono         cmp   ShapeCollisionX         bge   CheckY1         lda   ShapeCollisionWidth         clc         adc   ShapeCollisionX         cmp   ShapeCollisionX         blt   CheckY1gono     brl   noCheckX2  lda   ShapeCollisionWidthList,y         asl   a         asl   a         asl   a         asl   a         dec   a         clc         adc   ShapeCollisionXlist,y         cmp   ShapeCollisionX         bge   CheckY1         lda   ShapeCollisionX         clc         adc   ShapeCollisionWidth         cmp   ShapeCollisionX         bge   gono         cmp   ShapeCollisionXlist,y         bge   CheckY1         lda   ShapeCollisionWidthList,y         asl   a         asl   a         asl   a         asl   a         dec   a         clc         adc   ShapeCollisionXlist,y         cmp   ShapeCollisionXList,y         blt   CheckY1         bra   noCheckY1  lda   ShapeCollisionY         cmp   ShapeCollisionYlist,y         bge   CheckY2         clc         adc   ShapeCollisionHeight         cmp   ShapeCollisionYlist,y         bge   yes         lda   ShapeCollisionHeightList,y         asl   a         asl   a         asl   a         dec   a         clc         adc   ShapeCollisionYlist,y         cmp   ShapeCollisionYList,y         bge   no         cmp   ShapeCollisionY         bge   yes         lda   ShapeCollisionHeight         clc         adc   ShapeCollisionY         cmp   ShapeCollisionY         blt   yes         bra   noCheckY2  lda   ShapeCollisionHeightList,y         asl   a         asl   a         asl   a         dec   a         clc         adc   ShapeCollisionYlist,y         cmp   ShapeCollisionY         bge   yes         lda   ShapeCollisionY         clc         adc   ShapeCollisionHeight         cmp   ShapeCollisionY         bge   no         cmp   ShapeCollisionYlist,y         bge   yes         lda   ShapeCollisionHeightList,y         asl   a         asl   a         asl   a         asl   a         dec   a         clc         adc   ShapeCollisionYlist,y         cmp   ShapeCollisionYList,y         blt   yes         bra   noyes      lda   ShapeTypeList,x         cmp   ShapeCollisionTypeList,y         blt   skip2         sta   ShapeCollisionTypeList,yskip2    lda   ShapeTypeList,y         cmp   ShapeCollisionTypeList,x         blt   no         sta   ShapeCollisionTypeList,xno       iny         iny         cpy   NumberInShapeList         bge   over1         jmp   loop2over1    inx         inx         inx         inx         cpx   NumberInShapeList         bge   over2         dex         dex         jmp   loop3over2    anopInitShapeList entry         lda   #0         sta   NumberInShapeList         sta   MaxShapePriority         rts         end;data for shapeShapeData dataShapeAddress1List dc i2'$2C00,$2E00,$3000,$3200,$2800,$3400,$3600,$2A00'                  dc i2'$4600,$4600,$4600,$4600,$8800,$8800,$8800,$8800'ShapeAddress2List dc i2'$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000'                  dc i2'$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000'MaskAddress1List dc i2'$0C00,$0E00,$1000,$1200,$0800,$1400,$1600,$0A00'                 dc i2'$8600,$8600,$8600,$8600,$8600,$8600,$8600,$8600'MaskAddress2List dc i2'$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000'                 dc i2'$0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000'ShapeStartXList dc i2'0,0,0,0,0,0,0,0'                dc i2'$00,$08,$00,$08,$00,$08,$00,$08'ShapeStartYList dc i2'0,0,0,0,0,0,0,0'                dc i2'$00,$00,$10,$10,$00,$00,$10,$10'ShapeWidthList dc i2'$10,$10,$10,$10,$10,$10,$10,$10'               dc i2'$10,$10,$10,$10,$10,$10,$10,$10'ShapeHeightList dc i2'$20,$20,$20,$20,$20,$20,$20,$20'               dc i2'$20,$20,$20,$20,$20,$20,$20,$20'ShapeDrawWidthList dc i2'$10,$10,$10,$10,$10,$10,$10,$10'               dc i2'$08,$08,$08,$08,$08,$08,$08,$08'ShapeDrawHeightList dc i2'$20,$20,$20,$20,$20,$20,$20,$20'               dc i2'$10,$10,$10,$10,$10,$10,$10,$10'ShapeCollisionXOffsetList dc i2'0,0,0,0,0,0,0,0'                          dc i2'0,0,0,0,0,0,0,0'ShapeCollisionYOffsetList dc i2'0,0,0,0,0,0,0,0'                          dc i2'0,0,0,0,0,0,0,0'ShapeDataCollisionWidthList dc i2'$10,$10,$10,$10,$10,$10,$10,$10'               dc i2'$08,$08,$08,$08,$08,$08,$08,$08'ShapeDataCollisionHeightList dc i2'$20,$20,$20,$20,$20,$20,$20,$20'               dc i2'$10,$10,$10,$10,$10,$10,$10,$10'ShapeDataTypeList dc i2'1,1,1,1,1,1,1,1'                  dc i2'2,2,2,2,3,3,3,3'         end;data for shape listShapeListData dataShapeListSize equ   256*2ShapeNumberList ds ShapeListSizeShapeXlist ds ShapeListSizeShapeYlist ds ShapeListSizeShapeCollisionXList ds ShapeListSizeShapeCollisionYList ds ShapeListSizeShapeCollisionWidthList ds ShapeListSizeShapeCollisionHeightList ds ShapeListSizeShapeCollisionTypeList ds ShapeListSizeShapeTypeList ds ShapeListSizeShapeClassList ds ShapeListSizeShapePrioritylist ds ShapeListSize         end         align $10000Shape    data  shape         ds    $20000         end